name: Release

on:
  pull_request:
    types: [closed]
    branches:
      - main
  workflow_dispatch:
    inputs:
      target_sha:
        description: "Optional commit SHA to release (defaults to current workflow SHA)"
        required: false
        type: string

permissions:
  contents: write
  pull-requests: read

jobs:
  publish-release:
    if: >-
      ${{
        github.event_name == 'workflow_dispatch' ||
        (
          github.event.pull_request.merged == true &&
          github.event.pull_request.base.ref == 'main' &&
          startsWith(github.event.pull_request.title, 'release:')
        )
      }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Resolve release metadata
        id: metadata
        env:
          EVENT_NAME: ${{ github.event_name }}
          DISPATCH_TARGET_SHA: ${{ inputs.target_sha }}
          PR_MERGE_SHA: ${{ github.event.pull_request.merge_commit_sha }}
        run: |
          python - <<'PY'
          import os
          import re
          import subprocess
          import tomllib
          from pathlib import Path

          def git_show(commit_sha: str, path: str) -> str:
              try:
                  return subprocess.check_output(
                      ["git", "show", f"{commit_sha}:{path}"],
                      text=True,
                      stderr=subprocess.STDOUT,
                  )
              except subprocess.CalledProcessError as exc:
                  output = (exc.output or "").strip()
                  detail = output or str(exc)
                  raise SystemExit(
                      f"Unable to read '{path}' at commit '{commit_sha}': {detail}"
                  ) from exc
              except Exception as exc:  # noqa: BLE001
                  raise SystemExit(
                      f"Unable to read '{path}' at commit '{commit_sha}': {exc}"
                  ) from exc

          event_name = os.environ.get("EVENT_NAME", "").strip()
          dispatch_sha = os.environ.get("DISPATCH_TARGET_SHA", "").strip()
          pr_merge_sha = os.environ.get("PR_MERGE_SHA", "").strip()

          if event_name == "pull_request":
              target_sha = pr_merge_sha
          else:
              target_sha = dispatch_sha or os.environ.get("GITHUB_SHA", "").strip()

          if not target_sha:
              raise SystemExit("Unable to determine target release commit SHA.")

          pyproject_text = git_show(target_sha, "pyproject.toml")
          pyproject = tomllib.loads(pyproject_text)
          project = pyproject.get("project")
          if not isinstance(project, dict):
              raise SystemExit("pyproject.toml missing [project] table.")
          if "version" not in project:
              raise SystemExit("pyproject.toml missing [project].version.")
          version = str(project.get("version", "")).strip()
          if not version:
              raise SystemExit("pyproject.toml [project].version must be non-empty.")
          tag = f"v{version}"

          changelog = git_show(target_sha, "CHANGELOG.md")
          lines = changelog.splitlines()

          header_pattern = re.compile(rf"^##\s+{re.escape(tag)}\b")
          start_index = -1
          for index, line in enumerate(lines):
              if header_pattern.match(line):
                  start_index = index
                  break
          if start_index < 0:
              raise SystemExit(f"CHANGELOG.md missing section header for {tag}.")

          end_index = len(lines)
          for index in range(start_index + 1, len(lines)):
              if lines[index].startswith("## "):
                  end_index = index
                  break

          notes = "\n".join(lines[start_index:end_index]).strip()
          if not notes:
              raise SystemExit(f"Extracted release notes for {tag} are empty.")

          notes_path = Path("release-notes.md")
          notes_path.write_text(notes + "\n", encoding="utf-8")

          output_path = Path(os.environ["GITHUB_OUTPUT"])
          with output_path.open("a", encoding="utf-8") as output:
              output.write(f"target_sha={target_sha}\n")
              output.write(f"version={version}\n")
              output.write(f"tag={tag}\n")
              output.write(f"notes_path={notes_path}\n")
          PY

      - name: Check if GitHub release already exists
        id: tag_check
        uses: actions/github-script@v7
        env:
          TAG: ${{ steps.metadata.outputs.tag }}
        with:
          script: |
            const tag = process.env.TAG;
            try {
              await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag,
              });
              core.notice(`Release ${tag} already exists.`);
              core.setOutput("exists", "true");
            } catch (error) {
              if (error.status === 404) {
                core.notice(`Release ${tag} does not exist yet.`);
                core.setOutput("exists", "false");
              } else {
                throw error;
              }
            }

      - name: Create GitHub release (creates tag)
        if: steps.tag_check.outputs.exists != 'true'
        uses: actions/github-script@v7
        env:
          TAG: ${{ steps.metadata.outputs.tag }}
          TARGET_SHA: ${{ steps.metadata.outputs.target_sha }}
          NOTES_PATH: ${{ steps.metadata.outputs.notes_path }}
        with:
          script: |
            const fs = require("fs");
            const tag = process.env.TAG;
            const targetSha = process.env.TARGET_SHA;
            const notesPath = process.env.NOTES_PATH;
            const notes = fs.readFileSync(notesPath, "utf8");

            try {
              await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag,
              });
              core.notice(`Release ${tag} already exists; skipping.`);
            } catch (error) {
              if (error.status !== 404) {
                throw error;
              }

              await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: tag,
                target_commitish: targetSha,
                name: tag,
                body: notes,
                draft: false,
                prerelease: false,
                generate_release_notes: false,
              });
              core.notice(`Created release ${tag} for ${targetSha}.`);
            }
